# -*- mode: org -*-

* Emacs Setup
** Customization
Try to save customized values somewhere other than in the main init file
#+BEGIN_SRC emacs-lisp
(setq custom-file (expand-file-name "custom.el" user-emacs-directory))

;; create an empty custom.el if there isn't one already
(unless (file-exists-p custom-file) (write-region "" "" custom-file))

(load custom-file)
#+END_SRC

** Package Management
#+BEGIN_SRC emacs-lisp
(require 'package)
(package-initialize)
(setq package-archives
 '(;;("ELPA"      . "http://tromey.com/elpa/")
   ("gnu"       . "https://elpa.gnu.org/packages/")
   ("melpa"     . "https://melpa.milkbox.net/packages/")
   ;;("marmalade" . "http://marmalade-repo.org/packages")
))
#+END_SRC
** Load Paths
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path (concat user-init-file ".d/lisp"))
;;(add-to-list 'load-path (concat user-init-file ".d/helm"))
#+END_SRC

** General functions
#+BEGIN_SRC emacs-lisp
  (defun akt/touch-file (path)
    "Create an empty file unless the specified path already exists."
    (unless (file-exists-p path) (write-region "" "" path)))
#+END_SRC 

* OS Specific
#+BEGIN_SRC emacs-lisp
(setq akt/hostname system-name)
#+END_SRC
** OS X
*** iCloud stuff
#+BEGIN_SRC emacs-lisp
(eval-when-compile (require 'subr-x))

(defvar akt/icloud-directory
 "~/Library/Mobile Documents/com~apple~CloudDocs"
 "A directory that get sync'd to iCloud")

(defun akt/icloud-path (name)
 (concat akt/icloud-directory "/" name))

(setq akt/hostname (string-remove-suffix ".local" akt/hostname))
#+END_SRC
*** other
#+BEGIN_SRC emacs-lisp
  (cond
   ((string-equal system-type "darwin")
    (defun set-exec-path-from-shell-PATH ()
  "Set up Emacs' `exec-path' and PATH environment variable to match that used by the user's shell.

  This is particularly useful under Mac OSX, where GUI apps are not started from a shell."
      (interactive)
      (let ((path-from-shell (replace-regexp-in-string "[ \t\n]*$" "" (shell-command-to-string "$SHELL --login -i -c 'echo $PATH'"))))
        (setenv "PATH" path-from-shell)
        (setq exec-path (split-string path-from-shell path-separator))))

    (when (memq window-system '(mac ns))
      (set-exec-path-from-shell-PATH))

    (set-terminal-coding-system 'utf-8)
    (set-keyboard-coding-system 'utf-8)
    (prefer-coding-system 'utf-8)
    (message "noticed you're running OS X!")
    )
   )
#+END_SRC
* GUI Setup
** Windowing
#+BEGIN_SRC emacs-lisp
(setq inhibit-splash-screen t)
(tool-bar-mode -1)
;;(menu-bar-mode -1)
(scroll-bar-mode -1)
(setq split-height-threshold nil)
(require 'smooth-scrolling)
(setq smooth-scroll-margin 5)
#+END_SRC
** Tweaks
#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
(put 'narrow-to-region 'disabled nil)
(put 'downcase-region 'disabled nil)
(setq truncate-partial-width-windows nil)
#+END_SRC
** Colors
#+BEGIN_SRC emacs-lisp
(load-theme 'solarized-dark t)
(setq sml/theme 'dark)
(sml/setup)
#+END_SRC
** Visual Bell
#+BEGIN_SRC emacs-lisp
(defun my-bell-function ()
  (unless (memq this-command
    	'(isearch-abort abort-recursive-edit exit-minibuffer
              keyboard-quit mwheel-scroll down up next-line previous-line
              backward-char forward-char))
    (ding)))
(setq ring-bell-function 'my-bell-function)
#+END_SRC
** Git Gutter Fringe
#+begin_src ignored-emacs-lisp
  (if window-system
      (progn
        (require 'git-gutter-fringe)
        (setq git-gutter-fr:side 'right-fringe)
        (set-face-foreground 'git-gutter-fr:modified "yellow")
        (set-face-foreground 'git-gutter-fr:added "green")
        (set-face-foreground 'git-gutter-fr:deleted "red")
        (setq-default left-fringe-width 5)
        (setq-default right-fringe-width 5)

        (fringe-helper-define 'git-gutter-fr:modified nil
          "XXXXXX"
          "XXXXXX"
          "XXXXXX"
          "XXXXXX"
          "XXXXXX"
          "XXXXXX"
          "XXXXXX"
          "XXXXXX"
          "XXXXXX"
          "XXXXXX")

        (fringe-helper-define 'git-gutter-fr:added nil
          "XXXXXX"
          "XXXXXX"
          "XXXXXX"
          "XXXXXX"
          "XXXXXX"
          "XXXXXX"
          "XXXXXX"
          "XXXXXX"
          "XXXXXX"
          "XXXXXX
")

        (fringe-helper-define 'git-gutter-fr:deleted nil
          "XXXXXX"
          "XXXXXX"
          "XXXXXX"
          "XXXXXX"
          "XXXXXX"
          "XXXXXX"
          "XXXXXX"
          "XXXXXX"
          "XXXXXX"
          "XXXXXX
")

  ))

#+end_src
** Scrollwheel
#+begin_src emacs-lisp
(global-set-key (kbd "<wheel-right>") (lambda () (interactive) (message "wheeling right")))
(global-set-key (kbd "<wheel-left>") (lambda () (interactive) (message "wheeling left")))
(global-set-key (kbd "<double-wheel-right>") (lambda () (interactive) (message "wheeling right")))
(global-set-key (kbd "<double-wheel-left>") (lambda () (interactive) (message "wheeling left")))
(global-set-key (kbd "<triple-wheel-right>") (lambda () (interactive) (message "wheeling right")))
(global-set-key (kbd "<triple-wheel-left>") (lambda () (interactive) (message "wheeling left")))
#+end_src
* File/mode association
#+BEGIN_SRC emacs-lisp
(defvar auto-minor-mode-alist
  '(;;("\\.c\\'"  . fci-mode)
    ;;("\\.cc\\'" . fci-mode)
    ;;("\\.h\\'"  . fci-mode)

    ("\\.c\\'"  . whitespace-mode)
    ("\\.cc\\'" . whitespace-mode)
    ("\\.c\\'"  . whitespace-mode))
  "Alist of filename patterns vs correpsonding minor mode functions, see `auto-mode-alist'
All elements of this alist are checked, meaning you can enable multiple minor modes for the same regexp.")

(setq auto-mode-alist
  (append (mapcar 'purecopy
      '(("\\.c$"		 . c-mode)
        ("\\.h$"		 . c-mode)
        ("\\.a$"		 . c-mode)
        ("\\.w$"		 . cweb-mode)
        ("\\.cc$"		 . c++-mode)
        ("\\.cpp$"		 . c++-mode)
        ("\\.hpp$"		 . c++-mode)
        ("\\.S$"		 . asm-mode)
        ("\\.s$"		 . asm-mode)
        ("\\.tex$"		 . LaTeX-mode)
        ("\\.txi$"		 . Texinfo-mode)
        ("\\.el$"		 . emacs-lisp-mode)
        ("emacs"		 . emacs-lisp-mode)
        ("[mM]akefile"		 . makefile-mode)
        ("[mM]akefile.*"	 . makefile-mode)
        ("\\.mk"		 . makefile-mode)
        ("\\.cshrc"		 . sh-mode)
        ("\\.html$"		 . html-mode)
        ("\\.org$"		 . org-mode)
        ("\\.md$"          . markdown-mode)
        ("\\.bin$"         . hexl-mode)
        ("\\.swift$"       . swift-mode)
        ("\\.yaml  "       . yaml-mode)
        ("\\.html?\\'"     . web-mode)
        )) auto-mode-alist))

(defun enable-minor-mode-based-on-extension ()
  "check file name against auto-minor-mode-alist to enable minor modes
the checking happens for all pairs in auto-minor-mode-alist"
  (when buffer-file-name
    (let ((name buffer-file-name)
          (remote-id (file-remote-p buffer-file-name))
          (alist auto-minor-mode-alist))
      ;; Remove backup-suffixes from file name.
      (setq name (file-name-sans-versions name))
      ;; Remove remote file name identification.
      (when (and (stringp remote-id)
                 (string-match-p (regexp-quote remote-id) name))
        (setq name (substring name (match-end 0))))
      (while (and alist (caar alist) (cdar alist))
        (if (string-match (caar alist) name)
            (funcall (cdar alist) 1))
        (setq alist (cdr alist))))))

(add-hook 'find-file-hook 'enable-minor-mode-based-on-extension)

(add-hook 'c-mode-common-hook
          (lambda ()
            (when (derived-mode-p 'c-mode 'c++-mode 'java-mode) (ggtags-mode 1))))

#+END_SRC
* Language Support
** Python
#+BEGIN_SRC emacs-lisp
(require 'highlight-indentation)
#+END_SRC
** C++
#+BEGIN_SRC emacs-lisp
;; look for C++ headers
(setq magic-mode-alist
  (append (list  
       '("\\(.\\|\n\\)*\n[ ]*class" . c++-mode)
       '("\\(.\\|\n\\)*\n[ ]*namespace" . c++-mode))
      magic-mode-alist))
#+END_SRC
** Compilation
#+begin_src emacs-lisp
(setq compilation-scroll-output 'first-error)
#+end_src

#+begin_src ignored-emacs-lisp
      (defun akt/compile ()
        "Execute compile and resize the window"
        (interactive)
        (progn ()
               (call-interactively 'compile)
               (setq cur (selected-window))
               (setq w (get-buffer-window "*compilation*"))
               (select-window w)
               (set-window-dedicated-p (selected-window) 1)
               (setq h (window-height w))
               (shrink-window (- h 10))
               (select-window cur)))

      (defun akt/compilation-mode-hook ()
        "Make sure the compile window splits vertically"
        (progn ()
               (if (not (get-buffer-window "*compilation*"))
                   (split-window-vertically))))

      (add-hook 'compilation-mode-hook 'akt/compilation-mode-hook)

#+end_src
** lldb
#+begin_src emacs-lisp

(load-file "~/.emacs.d/lisp/gud.elc")
(defun file-local-name (file)
  "Return the local name component of FILE.
It returns a file name which can be used directly as argument of
`process-file', `start-file-process', or `shell-command'."
  (or (file-remote-p file 'localname) file))

;; http://stackoverflow.com/questions/9132826/stop-developer-tools-access-needs-to-take-control-of-another-process-for-debugg
;; sudo /usr/sbin/DevToolsSecurity --enable

#+end_src
* Org Mode Setup
Babel languages: gnuplot and dot
#+begin_src emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((gnuplot . t)
     (dot . t)
     (sql . t)
     (mscgen . t)
    )
   )
#+end_src

#+begin_src emacs-lisp
    (load-file "~/.emacs.d/lisp/ob-mscgen.elc")
#+end_src

Org mode data is saved within an iCloud directory so that it'll be replicated to all my machines.
#+BEGIN_SRC emacs-lisp
  (setq akt/agenda-avegant (akt/icloud-path "avegant.org"))
  (setq akt/agenda-versame (akt/icloud-path "versame.org"))
  (setq akt/agenda-panamint (akt/icloud-path "panamint.org"))
  (setq akt/gtd (akt/icloud-path "gtd.org"))
  (setq org-default-notes-file (akt/icloud-path (concat akt/hostname "-capture.org")))
  (akt/touch-file org-default-notes-file)
#+END_SRC 

#+begin_src emacs-lisp
  (defun avegant ()
    "Begin working on Avegant tasks"
    (interactive)
    (switch-to-buffer (find-file-noselect akt/agenda-avegant)))

  (defun gtd ()
    "Getting Things Done"
    (interactive)
    (find-file-noselect akt/agenda-versame)
    (switch-to-buffer (find-file-noselect akt/gtd)))

  (defun versame ()
    "Begin working on VersaMe tasks"
    (interactive)
    (switch-to-buffer (find-file-noselect akt/agenda-versame)))

  (defun panamint ()
    "Begin working on Panamint Engineering LLC tasks"
    (interactive)
    (switch-to-buffer (find-file-noselect akt/agenda-panamint)))
#+end_src

#+BEGIN_SRC emacs-lisp
  (setq org-agenda-files (list
                          org-default-notes-file
                          akt/agenda-avegant
                          akt/agenda-versame
                          akt/agenda-panamint
                          akt/gtd))

    (setq org-log-done t)
    (setq org-startup-indented t)
    (setq org-directory akt/icloud-directory)
    (add-hook 'org-mode-hook (lambda () (auto-revert-mode 1)))
    (setq org-refile-targets (list (cons akt/agenda-versame '(:maxlevel . 2))))
    (setq org-enforce-todo-dependencies t)
    (setq org-agenda-dim-blocked-tasks 'invisible)
#+END_SRC

#+begin_src emacs-lisp
  (defcustom org-clock-persist-file (akt/icloud-path "org-clock-save.el")
    "Where to save Andy's Org Mode clocks" :group 'org-clock :type 'string)
  (setq org-clock-persist 'history)
  (org-clock-persistence-insinuate)
#+end_src
** clock table stuff
#+begin_src emacs-lisp
(defun org-dblock-write:rangereport (params)
  "Display day-by-day time reports."
  (let* ((ts (plist-get params :tstart))
         (te (plist-get params :tend))
         (start (time-to-seconds
                 (apply 'encode-time (org-parse-time-string ts))))
         (end (time-to-seconds
               (apply 'encode-time (org-parse-time-string te))))
         day-numbers)
    (setq params (plist-put params :tstart nil))
    (setq params (plist-put params :end nil))
    (while (<= start end)
      (save-excursion
        (insert "\n\n"
                (format-time-string (car org-time-stamp-formats)
                                    (seconds-to-time start))
                "----------------\n")
        (org-dblock-write:clocktable
         (plist-put
          (plist-put
           params
           :tstart
           (format-time-string (car org-time-stamp-formats)
                               (seconds-to-time start)))
          :tend
          (format-time-string (car org-time-stamp-formats)
                              (seconds-to-time end))))
        (setq start (+ 86400 start))))))
#+end_src
** org-secretary
#+begin_src emacs-lisp
    (load-file "~/.emacs.d/lisp/org-secretary.elc")
    (setq org-todo-keywords
          '((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d)" "CANCELED(c)")
            (sequence "TASK(f)" "|" "DONE(d)")
            (sequence "MAYBE(m)" "|" "CANCELED(c)")))

    (setq org-todo-keyword-faces
          '(("TODO" . (:foreground "DarkOrange1" :weight bold))
            ("MAYBE" . (:foreground "sea green"))
            ("DONE" . (:foreground "light sea green"))
            ("CANCELED" . (:foreground "forest green"))
            ("TASK" . (:foreground "blue"))
            ))

    (setq org-tags-exclude-from-inheritance '("prj")
          org-stuck-projects '("+prj/-MAYBE-DONE"
                               ("TODO" "TASK") ()))
    (setq org-sec-me "akt")

    (setq org-agenda-custom-commands
          '(("h" "Work todos" tags-todo
             "-personal-doat={.+}-dowith={.+}/!-TASK"
             ((org-agenda-todo-ignore-scheduled t)))
            ("H" "All work todos" tags-todo "-personal/!-TASK-MAYBE"
             ((org-agenda-todo-ignore-scheduled nil)))
            ("A" "Work todos with doat or dowith" tags-todo
             "-personal+doat={.+}|dowith={.+}/!-TASK"
             ((org-agenda-todo-ignore-scheduled nil)))
            ("j" "TODO dowith and TASK with"
             ((org-sec-with-view "TODO dowith")
              (org-sec-where-view "TODO doat")
              (org-sec-assigned-with-view "TASK with")
              (org-sec-stuck-with-view "STUCK with")))
            ("J" "Interactive TODO dowith and TASK with"
             ((org-sec-who-view "TODO dowith")))))

    (setq akt/org-capture-meeting-template
  "* TODO akt/Discuss %? :MEET:
    SCHEDULED: %^{When?}T
  ,** Who
    - [ ] %(eval 'org-sec-me)
  ,** Agenda
    - [ ] item1\n   - [ ] item2
  ,** Discussion
  ,** Actions
    - [ ] action1
    - [ ] action2
  "
  )

  (setq org-agenda-custom-commands
        '(("h" "Work todos" tags-todo
           "-personal-doat={.+}-dowith={.+}/!-TASK"
           ((org-agenda-todo-ignore-scheduled t)))
          ("H" "All work todos" tags-todo "-personal/!-TASK-MAYBE"
           ((org-agenda-todo-ignore-scheduled nil)))
          ("A" "Work todos with doat or dowith" tags-todo
           "-personal+doat={.+}|dowith={.+}/!-TASK"
           ((org-agenda-todo-ignore-scheduled nil)))
          ("j" "TODO dowith and TASK with"
           ((org-sec-with-view "TODO dowith")
            (org-sec-where-view "TODO doat")
            (org-sec-assigned-with-view "TASK with")
            (org-sec-stuck-with-view "STUCK with")))
          ("J" "Interactive TODO dowith and TASK with"
           ((org-sec-who-view "TODO dowith")))))

  (setq akt/org-capture-todo-template
  "* TODO %?
  %U
  %a
  "
  )

  (setq akt/org-capture-note-template
  "* note: %?
  "
  )

  (setq org-capture-templates
        (list
         (list "t" "todo" 'entry '(file org-default-notes-file) akt/org-capture-todo-template)
         (list "m" "meeting" 'entry '(file org-default-notes-file) akt/org-capture-meeting-template)
         (list "n" "note" 'entry '(file org-default-notes-file) akt/org-capture-note-template)
         ))


#+end_src
** reveal.js
#+begin_src emacs-lisp
(require 'ox-reveal)
#+end_src
* Non-standard Features
** Git
#+BEGIN_SRC emacs-lisp
(setq magit-last-seen-setup-instructions "1.4.0")
(setq magit-push-always-verify nil)
(require 'git-blame)
#+END_SRC
** Fill Column
#+BEGIN_SRC emacs-lisp
(require 'fill-column-indicator)
;;(setq fci-rule-color "darkblue")
;;(setq-default fci-rule-column 80)
;;(setq fill-column 80)
#+END_SRC
** Whitespace and Tabs
#+BEGIN_SRC emacs-lisp
(require 'whitespace)
(setq whitespace-style '(face empty lines-tail trailing))

(setq default-tab-width 4)
(setq-default indent-tabs-mode nil)
#+END_SRC

** Parenthesis Matching
#+BEGIN_SRC emacs-lisp
(defun match-paren (arg)
  "Go to the matching paren if on a paren; otherwise insert %."
  (interactive "p")
  (cond ((looking-at "\\s\(") (forward-list 1) (backward-char 1))
        ((looking-at "\\s\)") (forward-char 1) (backward-list 1))
        (t (self-insert-command (or arg 1)))))

(global-set-key "%" 'match-paren)
#+END_SRC
** Helm
#+BEGIN_SRC emacs-lisp
;;(require 'helm)
;;(require 'helm-config)
;;(require 'helm-match-plugin)
#+END_SRC

** Occur Mode
#+BEGIN_SRC emacs-lisp
;; Alex Schroeder [http://www.emacswiki.org/cgi-bin/wiki/OccurBuffer]
(defun isearch-occur ()
  "*Invoke `occur' from within isearch."
  (interactive)
  (let ((case-fold-search isearch-case-fold-search))
    (occur (if isearch-regexp isearch-string (regexp-quote isearch-string)))))
#+END_SRC

** ECB
#+BEGIN_SRC ignore-emacs-lisp
(require 'ecb)
;;(require 'ecb-autoloads)
(setq ecb-compile-window-height 12)
#+END_SRC
** Reload Init File
#+BEGIN_SRC emacs-lisp
(defun reload-init-file ()
  "Reload Emacs initialization without quitting."
  (interactive)
  (org-babel-load-file "~/.emacs.d/init.org")
)
#+END_SRC

** Ido
#+begin_src emacs-lisp
(require 'ido)
(ido-mode t)
#+end_src
** smex
#+begin_src emacs-lisp
(require 'smex)
(smex-initialize)
#+end_src
** popwin
#+begin_src emacs-lisp
(require 'popwin)
(popwin-mode t)
#+end_src
** isearch-delete-something
#+begin_src emacs-lisp
  ;; An attempt at this Emacs SX question:
  ;; https://emacs.stackexchange.com/questions/10359/delete-portion-of-isearch-string-that-does-not-match-or-last-char-if-complete-m

  (defun isearch-delete-something ()
    "Delete non-matching text or the last character."
    ;; Mostly copied from `isearch-del-char' and Drew's answer on the page above
    (interactive)
    (if (= 0 (length isearch-string))
        (ding)
      (setq isearch-string
            (substring isearch-string
                       0
                       (or (isearch-fail-pos) (1- (length isearch-string)))))
      (setq isearch-message
            (mapconcat #'isearch-text-char-description isearch-string "")))
    (if isearch-other-end (goto-char isearch-other-end))
    (isearch-search)
    (isearch-push-state)
    (isearch-update))

  (define-key isearch-mode-map (kbd "<backspace>") 'isearch-delete-something)
#+end_src
** neotree
#+begin_src emacs-lisp
  (require 'neotree)
  (defun akt/eshell-here (dir)
    "Go to eshell and set current directory to the specified path"
    (interactive)
    (eshell)
    ;;(eshell/pushd ".")
    (cd dir)
    (goto-char (point-max))
    (eshell-kill-input)
    (eshell-send-input))

  (defun akt/eshell-at-neotree-dir (path _)
    "Launch eshell window at current directory within neotree."
    (interactive)
    (akt/eshell-here path))

  (defun akt/eshell-at-neotree-file (path _)
    "Launch eshell window at current directory within neotree."
    (interactive)
    (akt/eshell-here (file-name-directory path)))

  (define-key neotree-mode-map (kbd "!") (neotree-make-executor
                                          :dir-fn 'akt/eshell-at-neotree-dir
                                          :file-fn 'akt/eshell-at-neotree-file))

  ;;(push '(eshell-mode :position top :height 20) popwin:special-display-config)
#+end_src
** mouse commands
#+begin_src emacs-lisp
  (defun akt/delete-window-under-mouse (EVENT)
    "Deletes the window under the mouse."
    (interactive "e")
    (mouse-set-point EVENT)
    (delete-window))
#+end_src
** reveal.js
 #+begin_src emacs-lisp
(setq org-reveal-root "http://cdn.jsdelivr.net/reveal.js/3.0.0/")
 #+end_src
** multiple cursors
#+begin_src emacs-lisp
(require 'multiple-cursors)
    (global-set-key (kbd "C-S-c C-S-c") 'mc/edit-lines)
    (global-set-key (kbd "C->") 'mc/mark-next-like-this)
    (global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
    (global-set-key (kbd "C-c C-<") 'mc/mark-all-like-this)
#+end_src
* Keyboard Bindings
** Key Chords
#+BEGIN_SRC emacs-lisp
(require 'key-chord)
(key-chord-mode 1)
;;(key-chord-define-global "FF" 'clang-format)
(key-chord-define-global "nm" 'neotree-toggle)
(key-chord-define-global "cm" 'compile)
;;(key-chord-define-global "dm" 'gdb)
#+END_SRC
** Org Mode
#+BEGIN_SRC emacs-lisp
  (define-key global-map (kbd "C-c c") 'org-capture)

  (defun akt/visit-org-captures ()
    (interactive)
    (find-file org-default-notes-file))

  (defun akt/visit-default-org ()
    (interactive)
    (find-file (akt/icloud-path "avegant.org")))

  (define-key global-map (kbd "C-c o C") 'akt/visit-org-captures)
  (define-key global-map (kbd "C-c o <RET>") 'akt/visit-default-org)

  (global-set-key (kbd "C-c a") 'org-agenda)

#+END_SRC
** Other
#+BEGIN_SRC emacs-lisp

  (defun clang-format-region (char-start char-end &optional style)
    "Use clang-format to format the code between START and END according to STYLE.
  If called interactively uses the region or the current statement if there
  is no active region.  If no style is given uses `clang-format-style'."
    (interactive
     (if (use-region-p)
         (list (region-beginning) (region-end))
       (list (point) (point))))

    (unless style
      (setq style clang-format-style))

    (let ((start (1- (position-bytes char-start)))
          (end (1- (position-bytes char-end)))
          (cursor (1- (position-bytes (point))))
          (temp-buffer (generate-new-buffer " *clang-format-temp*"))
          (temp-file (make-temp-file "clang-format")))
      (unwind-protect
          (let (status stderr operations)
            (setq status
                  (call-process-region
                   (point-min) (point-max) clang-format-executable
                   nil `(,temp-buffer ,temp-file) nil

                   "-output-replacements-xml"
                   ;;"-sort-includes"
                   "-assume-filename" (or (buffer-file-name) "")
                   "-style" style
                   "-offset" (number-to-string start)
                   "-length" (number-to-string (- end start))
                   "-cursor" (number-to-string cursor)))
            (setq stderr
                  (with-temp-buffer
                    (insert-file-contents temp-file)
                    (when (> (point-max) (point-min))
                      (insert ": "))
                    (buffer-substring-no-properties
                     (point-min) (line-end-position))))

            (cond
             ((stringp status)
              (error "(clang-format killed by signal %s%s)" status stderr))
             ((not (equal 0 status))
              (error "(clang-format failed with code %d%s)" status stderr)))

            (with-current-buffer temp-buffer
              (setq operations (clang-format--extract (car (xml-parse-region)))))

            (let ((replacements (nth 0 operations))
                  (cursor (nth 1 operations))
                  (incomplete-format (nth 2 operations)))
              (save-excursion
                (mapc (lambda (rpl)
                        (apply #'clang-format--replace rpl))
                      replacements))
              (when cursor
                (goto-char (byte-to-position (1+ cursor))))
              (message "%s" incomplete-format)
              (if incomplete-format
                  (message "(clang-format: incomplete (syntax errors)%s)" stderr)
                (message "(clang-format: success%s)" stderr))))
        (delete-file temp-file)
        (when (buffer-name temp-buffer) (kill-buffer temp-buffer)))))


    (global-set-key (kbd "C-x g") 'magit-status)
    (define-key isearch-mode-map (kbd "C-o") 'isearch-occur)
    (when (require 'clang-format nil 'noerror)
      (global-set-key (kbd "C-c C-f C-r") 'clang-format-region)
      (global-set-key (kbd "C-c C-f C-b") 'clang-format-buffer))

    ;;(global-set-key (kbd "C-:") 'ac-complete-with-helm)
    ;;(define-key ac-complete-mode-map (kbd "C-:") 'ac-complete-with-helm)
    ;;(global-set-key (kbd "C-x C-f") 'helm-find-files)


    (require 'cl) ;; for lexical-let
    (defun ignore-error-wrapper (fn)
      "Funtion return new function that ignore errors.
       The function wraps a function with `ignore-errors' macro."
      (lexical-let ((fn fn))
        (lambda ()
          (interactive)
          (ignore-errors
            (funcall fn)))))

  (global-set-key [s-left] (ignore-error-wrapper 'windmove-left))
  (global-set-key [s-right] (ignore-error-wrapper 'windmove-right))
  (global-set-key [s-up] (ignore-error-wrapper 'windmove-up))
  (global-set-key [s-down] (ignore-error-wrapper 'windmove-down))
  (global-set-key [s-mouse-1] 'akt/delete-window-under-mouse)

  (global-set-key (kbd "M-x") 'smex)
  (global-set-key (kbd "M-X") 'smex-major-mode-commands)
  (global-set-key (kbd "C-c C-c M-x") 'execute-extended-command)
  (global-set-key (kbd "C-=") 'er/expand-region)

  (global-set-key (kbd "M-*") 'pop-tag-mark)
#+END_SRC
* gnus
#+begin_src unused-emacs-lisp
  (setq message-send-mail-function 'smtpmail-send-it
        smtpmail-starttls-credentials '(("smtp.gmail.com" 587 nil nil))
        smtpmail-auth-credentials '(("smtp.gmail.com" 587 "andyturk@gmail.com" nil))
        smtpmail-default-smtp-server "smtp.gmail.com"
        smtpmail-smtp-server "smtp.gmail.com"
        smtpmail-smtp-service 587
        starttls-gnutls-program "/opt/local/bin/gnutls-cli"
        starttls-extra-arguments nil
        starttls-use-gnutls t)
#+end_src
* C/C++ development tools
** CEDET (unused)
#+begin_src emacs-lisp-unused
(add-to-list 'semantic-default-submodes 'global-semantic-mru-bookmark-mode)
(add-to-list 'semantic-default-submodes 'global-semanticdb-minor-mode)
(add-to-list 'semantic-default-submodes 'global-semantic-idle-scheduler-mode)
(add-to-list 'semantic-default-submodes 'global-semantic-stickyfunc-mode)
(add-to-list 'semantic-default-submodes 'global-semantic-m3-mode)
(add-to-list 'semantic-default-submodes 'global-semantic-highlight-func-mode)
(add-to-list 'semantic-default-submodes 'global-semanticdb-minor-mode)

(semantic-mode 1)
#+end_src
** Irony
#+begin_src emacs-lisp
    (add-hook 'c++-mode-hook 'irony-mode)
    (add-hook 'c++-mode-hook 'company-mode)
    (add-hook 'c-mode-hook 'irony-mode)
    (add-hook 'c-mode-hook 'company-mode)
    (add-hook 'objc-mode-hook 'irony-mode)

    (defun akt:irony-mode-hook ()
      (define-key irony-mode-map [remap completion-at-point]
        'irony-completion-at-point-async)
      (define-key irony-mode-map [remap complete-symbol]
        'irony-completion-at-point-async))

    (add-hook 'irony-mode-hook 'akt:irony-mode-hook)
    (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options)

    (eval-after-load 'company
      '(add-to-list 'company-backends 'company-irony))
    (add-hook 'irony-mode-hook 'company-irony-setup-begin-commands)

    (when (boundp 'w32-pipe-read-delay)
      (setq w32-pipe-read-delay 0))
    ;; Set the buffer size to 64K on Windows (from the original 4K)
    (when (boundp 'w32-pipe-buffer-size)
      (setq irony-server-w32-pipe-buffer-size (* 64 1024)))

    (add-hook 'after-init-hook 'global-company-mode)

    (eval-after-load 'company
      '(add-to-list 'company-backends 'company-irony))

    (global-set-key [C-tab] 'company-complete)

#+end_src
